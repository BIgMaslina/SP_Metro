#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <locale.h>
#include <Windows.h>
#include < string.h >


/*
схема Питерского метрополитена представлена в виде графа, который представлен в виде списка смежных станций
для упрощения задачи на граф наложены следующие условия:
-граф неориентированный
-длины всех ребер одинаковые (не учитывается время переездов)
-посадка/высадка пассажиров происходит мгновенно
-пересадочные станции так-же будем считать смежными
-все станции обозначены уникальными номерами от 1 до 72

Формат списка:
массив 72х3; строка W[i-1] содержит список станций, смежных со станцией под номером i
L - массив, содержащий номера "фронтов волн" из алгоритма Ли (станции под номером i соответствует фронт L[i-1])
*/


int main()
{
	//setlocale(LC_ALL, "Rus"); 
	SetConsoleCP(1251);
	SetConsoleOutputCP(1251);
	//словарь с названиями станций (индекс + 1 = номер)
	char dict[72][30] = {"Парнас", "Проспект Просвещения", "Озерки", "Удельная", "Пионерская", "Черная речка", "Петроградская", "Горьковская", "Невский проспект",
	"Сенная площадь", "Технологический институт-2", "Фрунзенская", "Московские ворота", "Электросила", "Парк победы", "Московская", "Звездная",
	"Купчино", "Девяткино", "Гражданский проспект", "Академическая", "Политехническая", "Площадь Мужества", "Лесная", "Выборгская", "Площадь Ленина",
	"Чернышевская", "Площадь Восстания", "Владимирская", "Пушкинская", "Технический институт-1", "Балтийская", "Нарвская", "Кировский завод", "Автово",
	"Ленинский проспект", "Проспект Ветеранов", "Комендантский проспект", "Старая Деревня", "Крестовский остров", "Чкаловская", "Спортивная", "Адмиралтейская",
	"Садовая", "Звенигородская", "Обводный канал", "Волковская", "Бухарестская", "Международная", "Проспект Славы", "Дунайская", "Шушары", "Беговая",
	"Зенит", "Приморская", "Василеостровская", "Гостинный двор", "Маяковская", "Площадь Александра Невского-1", "Елизаровская", "Ломоносовская",
	"Пролетарская", "Обухово", "Рыбацкое", "Спасская", "Достоевская", "Лиговский проспект", "Площадь Александра Невского-2", "Новочеркасская",
	"Ладожская", "Проспект Большевиков", "Улица Дыбенко"};
	//W[]
	int W[72][4] = { {0, 2, 0, 0}, {1, 3, 0, 0}, {2, 4, 0, 0}, {3, 5, 0, 0}, {4, 6, 0, 0}, {5, 7, 0, 0}, {6, 8, 0, 0}, {7, 9, 0, 0}, 
		{8, 10, 57, 0}, {9, 11, 44, 65}, {10, 12, 31, 0}, {11, 13, 0, 0}, {12, 14, 0, 0}, {13, 15, 0, 0}, {14, 16, 0, 0}, {15, 17, 0, 0}, 
	{16, 18, 0, 0}, {17, 0, 0, 0}, {0, 20, 0, 0}, {19, 21, 0, 0}, {20, 22, 0, 0}, {21, 23, 0, 0}, {22, 24, 0, 0}, {23, 25, 0, 0},
	{24, 26, 0, 0}, {25, 27, 0, 0}, {26, 28, 0, 0}, {27, 29, 58, 0}, {28, 30, 66, 0}, {29, 31, 45, 0}, {30, 32, 11, 0}, {31, 33, 0, 0},
	{32, 34, 0, 0}, {33, 35, 0, 0}, {34, 36, 0, 0}, {35, 37, 0, 0}, {36, 0, 0, 0}, {0, 39, 0, 0}, {38, 40, 0, 0}, {39, 41, 0, 0},
	{40, 42, 0, 0}, {41, 43, 0, 0}, {42, 44, 0, 0}, {43, 45, 10, 65}, {44, 46, 30, 0}, {45, 47, 0, 0}, {46, 48, 0, 0},  {47, 49, 0, 0}, 
	{48, 50, 0, 0}, {49, 51, 0, 0}, {50, 52, 0, 0}, {51, 0, 0, 0}, {0, 54, 0, 0}, {53, 55, 0, 0}, {54, 56, 0, 0}, {55, 57, 0, 0}, 
		{56, 58, 9, 0}, {57, 59, 28, 0}, {58, 60, 68, 0}, {59, 61, 0, 0}, {60, 62, 0, 0}, {61, 63, 0, 0}, {62, 64, 0, 0}, {63, 0, 0, 0},
		{10, 44, 66, 0},  {65, 67, 29, 0}, {66, 68, 0, 0}, {67, 69, 59, 0}, {68, 70, 0, 0}, {69, 71, 0, 0}, {70, 72, 0, 0}, {71, 0, 0, 0} };
	int L[72];
	for (int i = 0; i < 72; i++)
	{
		L[i] = -1;
	}
	printf("Станция 1: ");
	char start[30];
	gets(start);
	printf("Станция 2: ");
	char end[30];
	gets(end);
	//определяем номера начальной и конечной станций (от 0 до 71)
	int lee_end, lee_start;
	for (int i = 0; i < 72; i++)
	{
		if (strcmp(dict[i], start)==0)
		{
			lee_end = i;
		}
		if (strcmp(dict[i],end)==0)
		{
			lee_start = i;
		}
	}
	L[lee_start] = 0;
	lee(W, L, lee_end, 0); // для алгоритма Ли прописана рекурсивная функция: каждая новая точка, через которую прошла "волна" становится источником новой "волны"
	find_de_way(W, L, lee_end, lee_start, lee_end, dict, 0);
	/*for (int i = 0; i < 72; i++)
	{
		printf("%d   %d\n", i, L[i]);
	}*/
	
}


//распределение фронтов волн по Ли
int lee(int W[][4], int* L, int lee_end, int max_front)
{
	//проверка условия: имеет ли конечная вершина по Ли собственный волновой фронт 
	if (L[lee_end] == -1)
	{
		//находим все вершины с максимальным фронтом волны
		for (int i = 0; i < 72; i++)
		{
			if (L[i] == max_front)
			{
				//всем смежным вершинам присваиваем фронт волны, увеличенный на 1
				for (int j = 0; j < 4; j++)
				{
					//проверка, не имеет ли смежная вершина собственный фронт
					if (W[i][j] != 0 && L[W[i][j] - 1]==-1)
					{
						L[W[i][j] - 1] = L[i] + 1;
					}
				}
			}
		}
		max_front=max_front+1;
		lee(W, L, lee_end, max_front);
	}
}

//нахождение кратчаишего пути
int find_de_way(int W[][4], int* L, int checkpoint, int finish, int lee_end, char dict[][30], int was_transition)
{
	int new_checkpoint = -1;
	for (int i = 0; i < 4; i++)
	{
		//двигаемся в обратную сторону по Ли: находим точку которая: 1) соседствует с чекпоинтом; 2) ее волновой фронт меньше фронта чекпоинта на 1
		//таким образом находим следующую станцию
		if (L[W[checkpoint][i] - 1] == L[checkpoint] - 1)
		{
			new_checkpoint = W[checkpoint][i] - 1;
			break;
		}
	}
	//проверка: начало/конец/переход/проезд для текущей станции
	if (checkpoint == finish)
	{
		printf("Маршрут окончен: %s\n", dict[checkpoint]);
	}
	else if (was_transition == 0)
	{
		if (checkpoint == lee_end)
		{
			printf("Начало маршрута: %s\n", dict[checkpoint]);
			if (abs(new_checkpoint - checkpoint) != 1)
			{
				printf("Переход: %s -> %s\n", dict[checkpoint], dict[new_checkpoint]);
			}
		}
		else if (abs(new_checkpoint - checkpoint) != 1)
		{
			printf("Выходите: %s\n", dict[checkpoint]);
			printf("Переход: %s -> %s\n", dict[checkpoint], dict[new_checkpoint]);
			was_transition = 1;
		}
		else
		{
			printf("Проезд: %s\n", dict[checkpoint]);
		}
	}
	else
	{
		printf("Садитесь: %s\n", dict[checkpoint]);
		was_transition = 0;
	}

	if (new_checkpoint != -1) // проверка, не окончен ли маршрут
	{
		find_de_way(W, L, new_checkpoint, finish, lee_end, dict, was_transition);
	}
}

